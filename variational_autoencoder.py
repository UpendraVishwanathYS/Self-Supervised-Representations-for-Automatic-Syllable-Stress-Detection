# -*- coding: utf-8 -*-
"""variational_autoencoder.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zjenhdyqrAuW2TPQQe3A6rmDFunVhivf
"""

from utils import *

class VariationalAutoencoder:
    def __init__(self, original_dim, intermediate_dim=64, latent_dim=19):
        self.original_dim = original_dim
        self.intermediate_dim = intermediate_dim
        self.latent_dim = latent_dim
        self.model = self.build_model()

    def sampling(self, args):
        """Reparameterization trick by sampling from an isotropic unit Gaussian."""
        z_mean, z_log_sigma = args
        batch = K.shape(z_mean)[0]
        dim = K.int_shape(z_mean)[1]
        epsilon = K.random_normal(shape=(batch, dim))
        return z_mean + K.exp(0.5 * z_log_sigma) * epsilon

    def build_model(self):
        # Input layers
        lab_input = keras.Input(shape=(1,), name="lab_input")
        ae_input = keras.Input(shape=(self.original_dim,), name="input")

        # Encoder
        h = layers.Dense(self.intermediate_dim, activation='relu')(ae_input)
        z_mean = layers.Dense(self.latent_dim)(h)
        z_log_sigma = layers.Dense(self.latent_dim)(h)
        z = layers.Lambda(self.sampling)([z_mean, z_log_sigma])
        z = layers.Dense(128)(z)  # Additional layer after sampling

        # Decoder
        x = layers.Dense(self.intermediate_dim, activation='relu')(z)
        d_pred = layers.Dense(self.original_dim, activation='sigmoid', name="same")(x)
        l = layers.concatenate([z, ae_input], axis=1)

        clf_features = layers.Dense(128, activation='relu')(l)
        clf_features = layers.Dropout(0.3)(clf_features)
        clf_features = layers.Dense(64, activation='relu')(clf_features)
        clf_features = layers.Dropout(0.2)(clf_features)
        clf_features = layers.Dense(32, activation='relu')(clf_features)
        clf_features = layers.Dense(4, activation='relu')(clf_features)
        clf_pred = layers.Dense(1, activation='sigmoid', name='stress')(clf_features)

        # Losses
        reconstruction_loss = keras.losses.mean_squared_error(ae_input, d_pred) * self.original_dim
        kl_loss = 1 + z_log_sigma - K.square(z_mean) - K.exp(z_log_sigma)
        kl_loss = K.sum(kl_loss, axis=-1) * -0.5
        vae_loss = K.mean(reconstruction_loss + kl_loss)

        l1 = keras.losses.binary_crossentropy(lab_input, clf_pred)
        clf_loss = K.mean(l1)

        # Create the model
        model = keras.Model(inputs=[ae_input, lab_input], outputs=[d_pred, clf_pred])
        model.add_loss(vae_loss)
        model.add_loss(clf_loss)

        return model

    def compile_model(self, learning_rate=0.001):
        """Compiles the model with specified optimizer and loss weights."""
        self.model.compile(
            optimizer=keras.optimizers.Adam(learning_rate=learning_rate),
            loss_weights={"same": 1, "stress": 1}
        )

    def fit(self, xtra_ac, ytra_ac, xval_ac, yval_ac,checkpoint_path,epochs=200, batch_size=32):
        """Fits the model to the training data."""
        mcp_save = ModelCheckpoint(filepath=checkpoint_path, save_best_only=True, monitor='val_loss', mode='min')
        callbacks = [EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=5),mcp_save]
        self.model.fit(
            {"input": xtra_ac, "lab_input": ytra_ac},
            {"same": xtra_ac, "stress": ytra_ac},
            epochs=epochs,
            batch_size=batch_size,
            validation_data=({"input": xval_ac, "lab_input": yval_ac}, {"same": xval_ac, "stress": yval_ac}),
            callbacks=callbacks
        )

    def evaluate(self, xval_ac, yval_ac):
        """Evaluates the model on validation data."""
        return self.model.evaluate(
            {"input": xval_ac, "lab_input": yval_ac},
            {"same": xval_ac, "stress": yval_ac}
        )

    def predict(self, xtest1, ytest1):
        """Makes predictions using the model."""
        return self.model.predict([xtest1, ytest1])

    def convert_function(self, pred_output):
      temp=[]
      for i in pred_output:
        if i>0.5:
          temp.append(1)
        else:
          temp.append(0)
      return temp

    def get_model(self):
      """Returns the compiled model."""
      return self.model